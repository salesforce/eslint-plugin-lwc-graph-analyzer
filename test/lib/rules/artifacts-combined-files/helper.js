/*
 * Copyright (c) 2025, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

const { readFileSync } = require('fs');
const { basename, dirname, join, parse, extname } = require('path');
const { Linter } = require('eslint');
const lwcGraphAnalyzer = require('../../../../lib/index');
const LwcBundle = require('../../../../lib/lwc-bundle');
const baseConfig = require('../../../../lib/configs/base');

/**
 * Creates ESLint configuration for a given rule
 * @param {string} rulename - Name of the rule to configure
 * @returns {Object} ESLint configuration
 */
function createLinterConfig(rulename) {
    const pluginPrefix = '@salesforce/lwc-graph-analyzer';
    const ruleConfig = {
        [`${pluginPrefix}/${rulename}`]: 'error'
    };
    const config = baseConfig;
    config.plugins = { [pluginPrefix]: lwcGraphAnalyzer };
    config.rules = ruleConfig;
    return config;
}

/**
 * Determines which code blocks should be processed by ESLint.
 * This function is used to filter which virtual files (code blocks) generated by the processor
 * should be analyzed by ESLint. In our case, we want to process both JavaScript and HTML files
 * that are part of the LWC bundle.
 *
 * @param {string} blockFilename - The filename of the code block being processed
 * @returns {boolean} True if the code block should be processed (has .js or .html extension), false otherwise
 */
function filterCodeBlock(blockFilename) {
    return blockFilename.endsWith('.js') || blockFilename.endsWith('.html');
}

/**
 * Runs ESLint on a bundle using file-based bundle setup
 * @param {string} rulePath - Path to the rule being tested
 * @param {string} target - Target file to lint
 * @returns {Array} ESLint messages
 */
function lintBundle(rulePath, target) {
    const rulename = parse(basename(rulePath)).name;
    const config = createLinterConfig(rulename);
    const testPath = join(dirname(rulePath), target);
    const srcCode = readFileSync(testPath).toString();

    const linter = new Linter();
    return linter.verify(srcCode, config, {
        filename: testPath,
        filterCodeBlock,
        reportUnusedDisableDirectives: false
    });
}

/**
 * Runs ESLint on a bundle using programmatic bundle setup
 * @param {string} rulePath - Path to the rule being tested
 * @param {string} target - Target file to lint
 * @returns {Array} ESLint messages
 */
function lintProgrammaticBundle(rulePath, target) {
    const rulename = parse(basename(rulePath)).name;
    const config = createLinterConfig(rulename);
    const testPath = join(dirname(rulePath), target);
    const srcCode = readFileSync(testPath).toString();

    // Create and set the bundle before linting
    const bundle = LwcBundle.lwcBundleFromFilesystem(srcCode, testPath, extname(testPath));
    lwcGraphAnalyzer.lwcBundle = bundle;

    const linter = new Linter();
    return linter.verify(srcCode, config, {
        filename: testPath,
        filterCodeBlock,
        reportUnusedDisableDirectives: false
    });
}

module.exports = {
    lintBundle,
    lintProgrammaticBundle
};
